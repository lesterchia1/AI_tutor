# -*- coding: utf-8 -*-
"""AI Tutor - Streamlit Version"""
import streamlit as st
import numpy as np
import os
import time
import groq
import uuid
import re
import tempfile

# LangChain imports
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_core.documents import Document
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import Chroma
from langchain_groq import ChatGroq

# Other imports
import chardet
import fitz  # PyMuPDF for PDFs
import docx  # python-docx for Word files
import gtts  # Google Text-to-Speech library
from pptx import Presentation  # python-pptx for PowerPoint files
import scipy.io.wavfile  # For audio processing

# Page configuration
st.set_page_config(
    page_title="AI Tutor - We.(POC)",
    page_icon="üìö",
    layout="wide"
)

# Initialize session states
if "chat_history" not in st.session_state:
    st.session_state.chat_history = []
if "chat_memory" not in st.session_state:
    st.session_state.chat_memory = []
if "audio_file" not in st.session_state:
    st.session_state.audio_file = None

# Check for API key
#if not os.getenv("GROQ_API_KEY"):
#    st.error("‚ùå GROQ_API_KEY not found. Please add it to your Streamlit secrets.")
#    st.stop()

# Initialize Groq API
#groq.api_key = os.getenv("GROQ_API_KEY")

# Initialize Chat Model
#chat_model = ChatGroq(model_name="llama-3.3-70b-versatile", api_key=groq.api_key)


# ===========================================
# SIMPLE FIX: Use st.secrets.get()
# ===========================================
# This works for both Streamlit Cloud AND local development
GROQ_API_KEY = st.secrets.get("GROQ_API_KEY")

# Fallback to environment variable
if not GROQ_API_KEY:
    GROQ_API_KEY = os.getenv("GROQ_API_KEY")

# Check if we have a key
if not GROQ_API_KEY:
    st.error("‚ùå GROQ_API_KEY not found in secrets or environment!")
    st.stop()

# Show debug info (remove in production)
st.sidebar.info(f"API Key loaded: {'‚úì' if GROQ_API_KEY else '‚úó'}")

# Initialize with the key
groq.api_key = GROQ_API_KEY

# Initialize Chat Model
chat_model = ChatGroq(
    model_name="llama-3.3-70b-versatile", 
    api_key=GROQ_API_KEY  # Pass key directly, not groq.api_key
)


# Initialize Embeddings and ChromaDB
os.makedirs("chroma_db", exist_ok=True)
embedding_model = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
vectorstore = Chroma(
    embedding_function=embedding_model,
    persist_directory="chroma_db"
)

# Prompt for quiz generation
quiz_prompt = """
You are an AI assistant specialized in education and assessment creation. Given an uploaded document or text, generate a quiz with a mix of multiple-choice questions (MCQs) and fill-in-the-blank questions. The quiz should be directly based on the key concepts, facts, and details from the provided material.
Generate 20 Questions.
Remove all unnecessary formatting generated by the LLM, including <think> tags, asterisks, markdown formatting, and any bold or italic text, as well as **, ###, ##, and # tags.
For each question:
- Provide 4 answer choices (for MCQs), with only one correct answer.
- Ensure fill-in-the-blank questions focus on key terms, phrases, or concepts from the document.
- Include an answer key for all questions.
- Ensure questions vary in difficulty and encourage comprehension rather than memorization.
- Additionally, implement an instant feedback mechanism:
    - When a user selects an answer, indicate whether it is correct or incorrect.
    - If incorrect, provide a brief explanation from the document to guide learning.
    - Ensure responses are concise and educational to enhance understanding.
Output Example:
1. Fill in the blank: The LLM Agent framework has a central decision-making unit called the _______________________.
Answer: Agent Core
Feedback: The Agent Core is the central component of the LLM Agent framework, responsible for managing goals, tool instructions, planning modules, memory integration, and agent persona.
2. What is the main limitation of LLM-based applications?
a) Limited token capacity
b) Lack of domain expertise
c) Prone to hallucination
d) All of the above
Answer: d) All of the above
Feedback: LLM-based applications have several limitations, including limited token capacity, lack of domain expertise, and being prone to hallucination, among others.
3. Given the following info, what is the value of P(jam|Rain)?
P(no Rain) = 0.8;
P(no Jam) = 0.2;
P(Rain|Jam) = 0.1
a) 0.016
b) 0.025
c) 0.1
d) 0.4
Answer: d) 0.4
Feedback: This question tests understanding of Bayes' Theorem by requiring the calculation of conditional probability using the given values.
"""

# Function to clean AI response by removing unwanted formatting
def clean_response(response):
    """Removes <think> tags, asterisks, and markdown formatting."""
    cleaned_text = re.sub(r"<think>.*?</think>", "", response, flags=re.DOTALL)
    cleaned_text = re.sub(r"(\*\*|\*|\[|\])", "", cleaned_text)
    cleaned_text = re.sub(r"^##+\s*", "", cleaned_text, flags=re.MULTILINE)
    cleaned_text = re.sub(r"\\", "", cleaned_text)
    cleaned_text = re.sub(r"---", "", cleaned_text)
    return cleaned_text.strip()

# Function to generate quiz based on content
def generate_quiz(content):
    prompt = f"{quiz_prompt}\n\nDocument content:\n{content}"
    response = chat_model.invoke(prompt)
    cleaned_response = clean_response(response.content)
    return cleaned_response

# Function to retrieve relevant documents from vectorstore based on user query
def retrieve_documents(query):
    results = vectorstore.similarity_search(query, k=3)
    return [doc.page_content for doc in results]

# Groq Whisper Transcriber
class GroqWhisperTranscriber:
    def __init__(self):
        self.client = groq.Client(api_key=groq.api_key)
    
    def transcribe_audio(self, audio_bytes, sample_rate):
        """Transcribe audio using Groq's Whisper API"""
        try:
            # Create temporary WAV file
            with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as f:
                temp_path = f.name
            
            # Write audio to file
            scipy.io.wavfile.write(temp_path, sample_rate, audio_bytes)
            
            # Transcribe with Groq API
            with open(temp_path, "rb") as audio_file:
                transcription = self.client.audio.transcriptions.create(
                    file=(temp_path, audio_file.read(), "audio/wav"),
                    model="whisper-large-v3-turbo",
                    response_format="text",
                    language="en"
                )
            
            # Clean up temporary file
            os.unlink(temp_path)
            
            text = transcription.strip()
            return text if text else "No speech detected. Please try again."
            
        except Exception as e:
            print(f"Groq transcription error: {str(e)}")
            # Clean up temp file if it exists
            try:
                if 'temp_path' in locals():
                    os.unlink(temp_path)
            except:
                pass
            return f"Transcription failed: {str(e)}"

# Initialize transcriber
try:
    transcriber = GroqWhisperTranscriber()
except Exception as e:
    st.warning(f"Failed to initialize transcriber: {e}")
    transcriber = None

# Function to play response as speech using gTTS
def speech_playback(text):
    try:
        # Generate a unique filename for each audio file
        unique_id = str(uuid.uuid4())
        audio_file = f"output_audio_{unique_id}.mp3"

        # Convert text to speech
        tts = gtts.gTTS(text, lang='en')
        tts.save(audio_file)

        # Return the path to the audio file
        return audio_file
    except Exception as e:
        print(f"Error in speech_playback: {e}")
        return None

# Function to detect encoding safely
def detect_encoding(file_path):
    try:
        with open(file_path, "rb") as f:
            raw_data = f.read(4096)
            detected = chardet.detect(raw_data)
            encoding = detected["encoding"]
        return encoding if encoding else "utf-8"
    except Exception:
        return "utf-8"

# Function to extract text from PDF
def extract_text_from_pdf(pdf_path):
    try:
        doc = fitz.open(pdf_path)
        text = "\n".join([page.get_text("text") for page in doc])
        return text if text.strip() else "No extractable text found."
    except Exception as e:
        return f"Error extracting text from PDF: {str(e)}"

# Function to extract text from Word files (.docx)
def extract_text_from_docx(docx_path):
    try:
        doc = docx.Document(docx_path)
        text = "\n".join([para.text for para in doc.paragraphs])
        return text if text.strip() else "No extractable text found."
    except Exception as e:
        return f"Error extracting text from Word document: {str(e)}"

# Function to extract text from PowerPoint files (.pptx)
def extract_text_from_pptx(pptx_path):
    try:
        presentation = Presentation(pptx_path)
        text = ""
        for slide in presentation.slides:
            for shape in slide.shapes:
                if hasattr(shape, "text"):
                    text += shape.text + "\n"
        return text if text.strip() else "No extractable text found."
    except Exception as e:
        return f"Error extracting text from PowerPoint: {str(e)}"

# Function to process documents safely
def process_document(file):
    try:
        # Save uploaded file
        file_extension = os.path.splitext(file.name)[-1].lower()
        with open(file.name, "wb") as f:
            f.write(file.getbuffer())
        
        if file_extension in [".png", ".jpg", ".jpeg"]:
            return "Error: Images cannot be processed for text extraction."
        
        if file_extension == ".pdf":
            content = extract_text_from_pdf(file.name)
        elif file_extension == ".docx":
            content = extract_text_from_docx(file.name)
        elif file_extension == ".pptx":
            content = extract_text_from_pptx(file.name)
        else:
            encoding = detect_encoding(file.name)
            with open(file.name, "r", encoding=encoding, errors="replace") as f:
                content = f.read()
        
        text_splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=50)
        documents = [Document(page_content=chunk) for chunk in text_splitter.split_text(content)]
        vectorstore.add_documents(documents)

        quiz = generate_quiz(content)
        return f"Document processed successfully (File Type: {file_extension}). Quiz generated:\n\n{quiz}"
    except Exception as e:
        return f"Error processing document: {str(e)}"

# Function to handle chatbot interactions
def chat_with_groq(user_input):
    try:
        # Retrieve relevant documents for additional context
        relevant_docs = retrieve_documents(user_input)
        context = "\n".join(relevant_docs) if relevant_docs else "No relevant documents found."

        # Construct proper prompting with conversation history
        system_prompt = "You are a helpful AI assistant. Answer questions accurately and concisely."
        conversation_history = "\n".join(st.session_state.chat_memory[-10:]) if st.session_state.chat_memory else ""
        prompt = f"{system_prompt}\n\nConversation History:\n{conversation_history}\n\nUser Input: {user_input}\n\nContext:\n{context}"

        # Call the chat model
        response = chat_model.invoke(prompt)

        # Clean response to remove any unwanted formatting
        cleaned_response_text = clean_response(response.content)

        # Append conversation history
        st.session_state.chat_memory.append(f"User: {user_input}")
        st.session_state.chat_memory.append(f"AI: {cleaned_response_text}")

        # Update chat history for display
        st.session_state.chat_history.append({"role": "user", "content": user_input})
        st.session_state.chat_history.append({"role": "assistant", "content": cleaned_response_text})

        # Convert response to speech
        audio_file = speech_playback(cleaned_response_text)
        if audio_file:
            st.session_state.audio_file = audio_file

        return cleaned_response_text
    except Exception as e:
        return f"Error: {str(e)}"

# Main UI
st.title("üìö AI Tutor - We.(POC)")
st.markdown("An interactive Personal AI Tutor chatbot to help with your learning needs.")

# Create tabs
tab1, tab2, tab3 = st.tabs(["ü§ñ AI Chatbot", "üìÑ Upload & Quiz", "üé• Introduction Video"])

# Tab 1: AI Chatbot
with tab1:
    col1, col2 = st.columns([3, 1])
    
    with col1:
        st.subheader("üí¨ Chat with AI Tutor")
        
        # Display chat history
        chat_container = st.container()
        with chat_container:
            for message in st.session_state.chat_history:
                if message["role"] == "user":
                    st.chat_message("user").write(message["content"])
                else:
                    st.chat_message("assistant").write(message["content"])
    
    with col2:
        st.subheader("üéµ Audio Response")
        if st.session_state.audio_file and os.path.exists(st.session_state.audio_file):
            st.audio(st.session_state.audio_file)
        else:
            st.info("No audio response yet")
    
    # Chat input
    user_input = st.chat_input("Ask a question...")
    
    if user_input:
        # Display user message
        st.chat_message("user").write(user_input)
        
        # Get AI response
        with st.spinner("Thinking..."):
            response = chat_with_groq(user_input)
        
        # Display AI response
        st.chat_message("assistant").write(response)
        
        # Refresh to show audio player
        st.rerun()
    
    # Voice recording section
    st.divider()
    st.subheader("üé§ Voice Input")
    
    # Audio recorder from streamlit-audiorecorder (alternative implementation)
    audio_bytes = st.audio_input("Record your question", type="wav")
    
    if audio_bytes and transcriber:
        with st.spinner("Transcribing..."):
            # Note: streamlit-audiorecorder provides bytes, need to convert
            # For now, using a simplified approach
            st.info("Audio transcription requires additional setup. Please type your question instead.")
    
    # Voice recording tips
    with st.expander("üé§ Voice Recording Tips", expanded=False):
        st.markdown("""
        **For perfect transcription:**
        - üé§ Speak clearly and directly into microphone
        - üîá Record in QUIET environment (no background noise)
        - üìè Keep recording between 2-10 seconds
        - üó£Ô∏è Speak at normal volume and pace
        - üì± Use a good quality microphone
        
        **Using Distill Whisper API:**
        - ‚úÖ High accuracy transcription
        - ‚úÖ No more "B-B-B" or "oh-oh-oh" errors
        - ‚úÖ Fast and reliable
        - ‚úÖ Professional grade speech recognition
        """)
    
    # Example questions
    with st.expander("üí° Example Questions", expanded=False):
        examples = [
            "Can you explain the concept of RLHF AI?",
            "What are AI transformers?",
            "What is MoE AI?",
            "What's gate networks AI?",
            "I am making a switch, please generating baking recipe?"
        ]
        
        cols = st.columns(2)
        for idx, example in enumerate(examples):
            col_idx = idx % 2
            if cols[col_idx].button(example, key=f"example_{idx}", use_container_width=True):
                st.session_state.chat_input = example
                st.rerun()
    
    # Clear chat button
    if st.button("üóëÔ∏è Clear Chat History", use_container_width=True):
        st.session_state.chat_history = []
        st.session_state.chat_memory = []
        st.session_state.audio_file = None
        st.rerun()

# Tab 2: Upload & Quiz
with tab2:
    st.subheader("üìÑ Upload Notes & Generate Quiz")
    
    col1, col2 = st.columns([2, 3])
    
    with col1:
        uploaded_file = st.file_uploader(
            "Upload Lecture Notes",
            type=["pdf", "docx", "pptx", "txt"],
            help="Supported formats: PDF, DOCX, PPTX, TXT"
        )
        
        if uploaded_file:
            if st.button("Process Document", use_container_width=True):
                with st.spinner("Processing document and generating quiz..."):
                    quiz_result = process_document(uploaded_file)
                    st.session_state.quiz_result = quiz_result
    
    with col2:
        st.subheader("Generated Quiz")
        if "quiz_result" in st.session_state:
            st.text_area("Quiz Output", st.session_state.quiz_result, height=400, label_visibility="collapsed")
        else:
            st.info("Upload a document and click 'Process Document' to generate a quiz")

# Tab 3: Introduction Video
with tab3:
    st.subheader("üé• Introduction Video")
    st.markdown("### Welcome to the Introduction Video")
    st.markdown("Music from Xu Mengyuan - China-O, musician Xu Mengyuan YUAN! | ÂæêÊ¢¶ÂúÜ - China-O Èü≥‰πê‰∫∫ÂæêÊ¢¶ÂúÜYUAN!")
    
    # Try to load video from different possible locations
    video_paths = [
        "We_not_me_video.mp4",
        "https://github.com/lesterchia1/AI_tutor/raw/main/We%20not%20me%20video.mp4",
        "./We_not_me_video.mp4"
    ]
    
    video_found = False
    for video_path in video_paths:
        try:
            st.video(video_path)
            video_found = True
            break
        except:
            continue
    
    if not video_found:
        st.warning("Introduction video not found. Please ensure the video file is in the correct location.")

